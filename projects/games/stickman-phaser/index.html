<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>火柴人对战（Phaser版）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #222; }
        #game-container { width: 100vw; height: 100vh; overflow: hidden; }
    </style>
</head>
<body>
<div id="game-container"></div>
<script>
/**
 * 火柴人对战（Phaser.js 3）
 * - 玩家：WASD 控制，J 攻击
 * - AI：自动追击玩家
 * - 双方有血条，击败对方得分
 * - 简单音效
 * - 只用一个 index.html 文件
 * @author AI
 */
const GAME_WIDTH = 960;
const GAME_HEIGHT = 540;
const PLAYER_SPEED = 220;
const JUMP_SPEED = 420;
const ATTACK_RANGE = 48;
const ATTACK_COOLDOWN = 500;
const MAX_HP = 5;

let hitSound, jumpSound, winSound;

class Stickman {
    constructor(scene, x, y, color, isPlayer) {
        this.scene = scene;
        this.color = color;
        this.isPlayer = isPlayer;
        this.hp = MAX_HP;
        this.lastAttack = 0;
        this.facing = 1;
        this.isAttacking = false;
        this.attackAnimTime = 0;
        this.score = 0;
        // 物理体
        this.body = scene.physics.add.image(x, y, null);
        this.body.setSize(24, 64);
        this.body.setCollideWorldBounds(true);
        this.body.setBounce(0.1);
        this.body.setGravityY(900);
        // 画图
        this.graphics = scene.add.graphics();
    }
    update(time) {
        // 攻击动画计时
        if (this.isAttacking && time > this.attackAnimTime) {
            this.isAttacking = false;
        }
        // 画 stickman
        this.graphics.clear();
        this.graphics.save();
        this.graphics.translate(this.body.x, this.body.y);
        this.graphics.scale(this.facing, 1);
        this.graphics.lineStyle(4, Phaser.Display.Color.HexStringToColor(this.color).color);
        // 头
        this.graphics.strokeCircle(0, -32, 14);
        // 身体
        this.graphics.lineBetween(0, -18, 0, 18);
        // 手
        this.graphics.lineBetween(0, -8, -16, 8);
        this.graphics.lineBetween(0, -8, 16, 8);
        // 腿
        this.graphics.lineBetween(0, 18, -12, 38);
        this.graphics.lineBetween(0, 18, 12, 38);
        // 攻击动画
        if (this.isAttacking) {
            this.graphics.lineStyle(6, 0xffffff);
            this.graphics.lineBetween(0, 0, 32, 0);
        }
        this.graphics.restore();
    }
    attack(time) {
        if (time - this.lastAttack < ATTACK_COOLDOWN) return false;
        this.isAttacking = true;
        this.attackAnimTime = time + 180;
        this.lastAttack = time;
        return true;
    }
    setVelocity(x, y) {
        this.body.setVelocity(x, y !== undefined ? y : this.body.body.velocity.y);
    }
    get x() { return this.body.x; }
    get y() { return this.body.y; }
    set x(v) { this.body.x = v; }
    set y(v) { this.body.y = v; }
    onFloor() { return this.body.body.blocked.down; }
}

class MainScene extends Phaser.Scene {
    constructor() { super({ key: "MainScene" }); }
    preload() {
        this.load.audio("hit", "https://cdn.jsdelivr.net/gh/Chalarangelo/phaser-sfx/hit.mp3");
        this.load.audio("jump", "https://cdn.jsdelivr.net/gh/Chalarangelo/phaser-sfx/jump.mp3");
        this.load.audio("win", "https://cdn.jsdelivr.net/gh/Chalarangelo/phaser-sfx/win.mp3");
    }
    create() {
        hitSound = this.sound.add("hit");
        jumpSound = this.sound.add("jump");
        winSound = this.sound.add("win");
        // 地面
        this.ground = this.physics.add.staticGroup();
        this.ground.create(GAME_WIDTH/2, GAME_HEIGHT-32, null).setDisplaySize(GAME_WIDTH, 64).refreshBody();
        // 玩家
        this.player = new Stickman(this, 200, GAME_HEIGHT-100, "#3af", true);
        // AI
        this.ai = new Stickman(this, 760, GAME_HEIGHT-100, "#fa3", false);
        // 碰撞
        this.physics.add.collider(this.player.body, this.ground);
        this.physics.add.collider(this.ai.body, this.ground);
        // 输入
        this.cursors = this.input.keyboard.addKeys({
            up: "W", left: "A", down: "S", right: "D", attack: "J"
        });
        // 分数
        this.playerScore = 0;
        this.aiScore = 0;
        // 摄像机
        this.cameras.main.setBackgroundColor("#222");
        // 禁止右键菜单
        this.input.mouse.disableContextMenu();
        // UI
        this.ui = this.add.graphics();
    }
    update(time, delta) {
        // 玩家操作
        let vx = 0;
        if (this.cursors.left.isDown) vx -= PLAYER_SPEED;
        if (this.cursors.right.isDown) vx += PLAYER_SPEED;
        this.player.setVelocity(vx);
        if (this.cursors.up.isDown && this.player.onFloor()) {
            this.player.setVelocity(vx, -JUMP_SPEED);
            jumpSound.play();
        }
        // 朝向
        if (vx !== 0) this.player.facing = vx > 0 ? 1 : -1;
        // 攻击
        if (Phaser.Input.Keyboard.JustDown(this.cursors.attack)) {
            if (this.player.attack(time)) {
                this.checkAttack(this.player, this.ai, time);
            }
        }
        // AI 简单追击
        let aiVx = 0;
        if (this.ai.x < this.player.x - 8) aiVx = PLAYER_SPEED * 0.8;
        else if (this.ai.x > this.player.x + 8) aiVx = -PLAYER_SPEED * 0.8;
        this.ai.setVelocity(aiVx);
        if (this.ai.onFloor() && Math.abs(this.ai.x - this.player.x) < 80 && Math.random() < 0.02) {
            this.ai.setVelocity(aiVx, -JUMP_SPEED);
        }
        this.ai.facing = aiVx > 0 ? 1 : -1;
        // AI 攻击
        if (Math.abs(this.ai.x - this.player.x) < ATTACK_RANGE + 8 && Math.abs(this.ai.y - this.player.y) < 32) {
            if (time - this.ai.lastAttack > ATTACK_COOLDOWN && Math.random() < 0.08) {
                if (this.ai.attack(time)) {
                    this.checkAttack(this.ai, this.player, time);
                }
            }
        }
        // 死亡检测
        if (this.player.hp <= 0) {
            this.aiScore++;
            winSound.play();
            this.resetRound();
        } else if (this.ai.hp <= 0) {
            this.playerScore++;
            winSound.play();
            this.resetRound();
        }
        // 画 stickman
        this.player.update(time);
        this.ai.update(time);
        // 画 UI
        this.drawUI();
    }
    checkAttack(attacker, defender, time) {
        // 攻击判定
        let dx = (defender.x - attacker.x) * attacker.facing;
        let dy = Math.abs(defender.y - attacker.y);
        if (dx > 0 && dx < ATTACK_RANGE && dy < 32) {
            defender.hp--;
            hitSound.play();
        }
    }
    resetRound() {
        this.player.x = 200;
        this.player.y = GAME_HEIGHT-100;
        this.player.hp = MAX_HP;
        this.ai.x = 760;
        this.ai.y = GAME_HEIGHT-100;
        this.ai.hp = MAX_HP;
    }
    drawUI() {
        this.ui.clear();
        // 血条
        // 玩家血条
        this.ui.fillStyle(0x3afaff, 1);
        this.ui.fillRect(40, 30, 120 * (this.player.hp / MAX_HP), 18);
        this.ui.lineStyle(2, 0xffffff);
        this.ui.strokeRect(40, 30, 120, 18);
        this.ui.fillStyle(0xffffff, 1);
        this.ui.setFontSize && this.ui.setFontSize(16);
        // AI 血条
        this.ui.fillStyle(0xfaaf3a, 1);
        this.ui.fillRect(GAME_WIDTH-160, 30, 120 * (this.ai.hp / MAX_HP), 18);
        this.ui.lineStyle(2, 0xffffff);
        this.ui.strokeRect(GAME_WIDTH-160, 30, 120, 18);
        // 分数
        this.ui.lineStyle(0);
        this.ui.fillStyle(0xffffff, 1);
        this.ui.fillRect(GAME_WIDTH/2-60, 10, 120, 24);
        this.ui.lineStyle(2, 0x222222);
        this.ui.strokeRect(GAME_WIDTH/2-60, 10, 120, 24);
        this.addText && this.addText.destroy && this.addText.destroy();
        if (!this.scoreText) {
            this.scoreText = this.add.text(GAME_WIDTH/2-50, 14, '', {font: '20px monospace', fill: '#222'});
        }
        this.scoreText.setText(`玩家 ${this.playerScore} : ${this.aiScore} AI`);
    }
}

const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: "game-container",
    backgroundColor: "#222",
    physics: {
        default: "arcade",
        arcade: {
            gravity: { y: 900 },
            debug: false
        }
    },
    scene: [MainScene]
};

window.onload = () => {
    new Phaser.Game(config);
};
</script>
</body>
</html> 