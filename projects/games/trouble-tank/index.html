<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¦å…‹å¤§æˆ˜ - è¶…å¤§æ— ç¼ç°è‰²åœ°å›¾</title>
    <style>
        body { background: #222; margin: 0; }
        #game-container {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: center;
            /* é€‚åº”å†…å®¹é«˜åº¦ */
        }
        #player-panel {
            width: 90px;
            min-width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 80vh;
            margin-right: 8px;
            background: linear-gradient(135deg, rgba(40,40,60,0.92) 60%, rgba(60,60,80,0.7) 100%);
            border-radius: 16px;
            box-shadow: 0 4px 24px #111a, 0 0 0 2px #3338;
            padding-top: 18px;
            border: 1.5px solid #444a;
        }
        #player-name {
            background: linear-gradient(90deg, #fff 30%, #aaf 70%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 6px #aaf8, 0 2px 6px #222a;
            letter-spacing: 1px;
        }
        #hp-bar-bg {
            width: 60px;
            height: 12px;
            background: #2a2a2a;
            border-radius: 6px;
            margin-bottom: 4px;
            position: relative;
            border: 1.5px solid #aa2222;
            box-shadow: 0 0 4px #aa222288;
        }
        #hp-bar-fg {
            height: 100%;
            background: linear-gradient(90deg, #22dd22 60%, #66ff66 100%);
            border-radius: 6px;
            transition: width 0.25s cubic-bezier(.4,1.6,.6,1);
            box-shadow: 0 0 6px #66ff6688;
        }
        #hp-bar-value {
            position: absolute;
            left: 0; right: 0; top: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 2px #222, 0 0 2px #fff8;
            pointer-events: none;
        }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        .map-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(60,60,80,0.92) 60%, rgba(100,100,140,0.7) 100%);
            border-radius: 24px;
            box-shadow: 0 6px 32px #111a, 0 0 0 3px #3338;
            padding: 18px;
            margin: 0 0 0 0;
            border: 2.5px solid #444a;
            min-width: 0;
        }
        canvas { image-rendering: pixelated; image-rendering: crisp-edges; border-radius: 16px; box-shadow: 0 0 12px #2228; background: #333; }
        #settings-modal {
            position: fixed;
            left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(30,30,40,0.45);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #settings-panel {
            background: linear-gradient(135deg, #23243a 60%, #3a3a5a 100%);
            border-radius: 18px;
            box-shadow: 0 8px 32px #111b, 0 0 0 2px #3338;
            padding: 32px 32px 24px 32px;
            min-width: 320px;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .settings-title {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-shadow: 0 2px 8px #222a;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #eee;
            font-size: 15px;
            margin-bottom: 2px;
        }
        #settings-panel label {
            min-width: 80px;
            text-align: right;
        }
        #settings-panel input[type="text"] {
            border-radius: 6px;
            border: 1.5px solid #444a;
            padding: 4px 8px;
            font-size: 15px;
            background: #23243a;
            color: #fff;
            outline: none;
        }
        #settings-panel input[type="color"] {
            width: 32px; height: 22px; border: none; background: none; cursor: pointer;
        }
        #settings-panel select {
            border-radius: 6px;
            border: 1.5px solid #444a;
            padding: 4px 8px;
            font-size: 15px;
            background: #23243a;
            color: #fff;
            outline: none;
        }
        #settings-close {
            background: linear-gradient(90deg, #4a6cff 60%, #6cf 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            padding: 6px 24px;
            cursor: pointer;
            box-shadow: 0 2px 8px #2224;
            transition: background 0.2s;
        }
        #settings-close:hover {
            background: linear-gradient(90deg, #6cf 60%, #4a6cff 100%);
        }
    </style>
    <style>
    #start-modal {
        position: fixed;
        left: 0; top: 0; right: 0; bottom: 0;
        background: rgba(30,30,40,0.55);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #start-panel {
        background: linear-gradient(135deg, #23243a 60%, #3a3a5a 100%);
        border-radius: 22px;
        box-shadow: 0 8px 32px #111b, 0 0 0 2px #3338;
        padding: 48px 48px 32px 48px;
        min-width: 340px;
        min-height: 220px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 18px;
        animation: winner-pop 0.5s cubic-bezier(.4,1.6,.6,1);
    }
    .start-title {
        font-size: 32px;
        font-weight: bold;
        color: #fff;
        margin-bottom: 18px;
        letter-spacing: 2px;
        text-shadow: 0 2px 8px #222a;
    }
    .start-row {
        display: flex;
        align-items: center;
        gap: 12px;
        color: #eee;
        font-size: 18px;
        margin-bottom: 2px;
    }
    #start-btn {
        background: linear-gradient(90deg, #4a6cff 60%, #6cf 100%);
        color: #fff;
        border: none;
        border-radius: 8px;
        font-size: 20px;
        font-weight: bold;
        padding: 10px 36px;
        cursor: pointer;
        box-shadow: 0 2px 8px #2224;
        transition: background 0.2s;
        margin-top: 18px;
    }
    #start-btn:hover {
        background: linear-gradient(90deg, #6cf 60%, #4a6cff 100%);
    }
    </style>
    <style>
    /* ç§‘æŠ€æ„Ÿæš—è‰²è°ƒå¼€å§‹ç•Œé¢ */
    #start-modal {
        position: fixed; left: 0; top: 0; right: 0; bottom: 0;
        background: radial-gradient(ellipse at center, #181c2a 60%, #10121a 100%);
        z-index: 10001; display: flex; align-items: center; justify-content: center;
        overflow: hidden;
        animation: fadeInBg 1s;
    }
    @keyframes fadeInBg { from { opacity: 0; } to { opacity: 1; } }
    #start-panel {
        background: linear-gradient(135deg, #23243a 60%, #23243a 100%);
        border-radius: 22px; box-shadow: 0 8px 32px #111b, 0 0 0 2px #3338;
        padding: 48px 48px 32px 48px; min-width: 360px; min-height: 260px;
        display: flex; flex-direction: column; align-items: center; gap: 18px;
        animation: popIn 0.7s cubic-bezier(.4,1.6,.6,1);
        border: 1.5px solid #3af;
        box-shadow: 0 0 40px #3af8, 0 0 0 2px #3338;
        position: relative;
    }
    @keyframes popIn { 0% { transform: scale(0.7); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    .start-title {
        font-size: 36px; font-weight: bold; color: #fff; margin-bottom: 18px;
        letter-spacing: 2px; text-shadow: 0 2px 16px #3af8, 0 2px 8px #222a;
        text-align: center;
    }
    .start-row {
        display: flex; align-items: center; gap: 12px; color: #eee; font-size: 18px; margin-bottom: 2px;
    }
    #start-btn, #start-settings-btn, #start-maker-btn {
        background: linear-gradient(90deg, #4a6cff 60%, #6cf 100%);
        color: #fff; border: none; border-radius: 8px; font-size: 20px; font-weight: bold;
        padding: 10px 36px; cursor: pointer; box-shadow: 0 2px 8px #2224; transition: background 0.2s;
        margin-top: 18px; margin-bottom: 0; margin-right: 0; margin-left: 0;
        letter-spacing: 1px;
    }
    #start-btn:hover, #start-settings-btn:hover, #start-maker-btn:hover {
        background: linear-gradient(90deg, #6cf 60%, #4a6cff 100%);
        box-shadow: 0 0 16px #3af8;
    }
    #start-btn { margin-bottom: 8px; }
    #start-maker-btn { background: linear-gradient(90deg, #333 60%, #3af 100%); font-size: 16px; margin-top: 8px; }
    #start-maker-btn:hover { background: linear-gradient(90deg, #3af 60%, #333 100%); }
    #start-settings-btn { background: linear-gradient(90deg, #222 60%, #6cf 100%); font-size: 16px; margin-top: 8px; }
    #start-settings-btn:hover { background: linear-gradient(90deg, #6cf 60%, #222 100%); }
    #start-ai-count { width: 48px; font-size: 18px; border-radius: 6px; border: 1.5px solid #3af; background: #181c2a; color: #fff; text-align: center; }
    /* åˆ¶ä½œäººå¼¹çª— */
    #maker-modal { position: fixed; left: 0; top: 0; right: 0; bottom: 0; background: rgba(20,30,40,0.7); z-index: 10002; display: flex; align-items: center; justify-content: center; animation: fadeInBg 0.5s; }
    #maker-panel { background: #23243a; border-radius: 18px; box-shadow: 0 8px 32px #111b, 0 0 0 2px #3af8; padding: 36px 36px 24px 36px; min-width: 320px; min-height: 120px; display: flex; flex-direction: column; align-items: center; gap: 18px; animation: popIn 0.5s; border: 1.5px solid #3af; }
    .maker-title { font-size: 24px; font-weight: bold; color: #3af; margin-bottom: 8px; letter-spacing: 2px; text-shadow: 0 2px 8px #3af8; }
    .maker-name { font-size: 20px; color: #fff; margin-bottom: 8px; text-shadow: 0 2px 8px #222a; }
    .maker-btn { background: linear-gradient(90deg, #4a6cff 60%, #6cf 100%); color: #fff; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; padding: 8px 28px; cursor: pointer; box-shadow: 0 2px 8px #2224; transition: background 0.2s; margin-top: 12px; }
    .maker-btn:hover { background: linear-gradient(90deg, #6cf 60%, #4a6cff 100%); }
    /* å¤ªç©ºå¦å…‹åŠ¨ç”»èƒŒæ™¯ */
    #start-bg-canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; z-index: 0; pointer-events: none; }
    </style>
    <style>
    /* è‡ªå®šä¹‰é¼ æ ‡æ ·å¼ */
    body, #game-container, .map-wrapper, canvas {
        cursor: none !important;
    }
    #custom-cursor {
        position: fixed; left: 0; top: 0; width: 32px; height: 32px; pointer-events: none; z-index: 10010;
        mix-blend-mode: lighten;
        transition: filter 0.2s;
    }
    #custom-cursor .cursor-dot {
        position: absolute; left: 12px; top: 12px; width: 8px; height: 8px; border-radius: 50%; background: #3af; box-shadow: 0 0 12px #3af8, 0 0 24px #3af8; }
    #custom-cursor .cursor-cross {
        position: absolute; left: 15px; top: 0; width: 2px; height: 32px; background: linear-gradient(#3af,#fff,#3af); border-radius: 1px; opacity: 0.7; }
    #custom-cursor .cursor-cross-h {
        position: absolute; left: 0; top: 15px; width: 32px; height: 2px; background: linear-gradient(90deg,#3af,#fff,#3af); border-radius: 1px; opacity: 0.7; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="player-panel">
            <div id="player-name">ç©å®¶1</div>
            <div id="hp-bar-bg">
                <div id="hp-bar-fg" style="width: 100%"></div>
                <div id="hp-bar-value">100/100</div>
            </div>
        </div>
        <div class="map-wrapper">
            <!-- Phaser canvasä¼šè‡ªåŠ¨æ’å…¥åˆ°è¿™é‡Œ -->
        </div>
    </div>
    <!-- è®¾ç½®çª—å£ -->
    <div id="settings-modal" style="display:none;">
        <div id="settings-panel">
            <div class="settings-title">è®¾ç½®</div>
            <div class="settings-row">
                <label>æŠ—é”¯é½¿ï¼š</label>
                <select id="antialias-select">
                    <option value="on">å¼€å¯ï¼ˆæœ€å¤§ï¼‰</option>
                    <option value="off">å…³é—­ï¼ˆåƒç´ é£ï¼‰</option>
                </select>
            </div>
            <div class="settings-row">
                <label>å§“åï¼š</label>
                <input id="name-input" type="text" maxlength="12" value="ä¸»ç©å®¶1" />
            </div>
            <div class="settings-row">
                <label>å¦å…‹é¢œè‰²ï¼š</label>
                <input id="tank-color-input" type="color" value="#339933" />
            </div>
            <div class="settings-row">
                <label>å­å¼¹é¢œè‰²ï¼š</label>
                <input id="bullet-color-input" type="color" value="#ffff00" />
            </div>
            <div class="settings-row">
                <label>æ³›å…‰é¢œè‰²ï¼š</label>
                <input id="glow-color-input" type="color" value="#99ff99" />
            </div>
            <div class="settings-row">
                <label>é»‘å¤œæ¨¡å¼ï¼š</label>
                <input id="night-mode-input" type="checkbox" />
            </div>
            <div class="settings-row" style="justify-content:center;">
                <button id="settings-close">å…³é—­</button>
            </div>
        </div>
    </div>
    <div id="start-modal">
        <canvas id="start-bg-canvas"></canvas>
        <div id="start-panel">
            <div class="start-title">å¦å…‹å¤§æˆ˜</div>
            <div class="start-row">
                <label for="start-ai-count">ç”µè„‘ç©å®¶æ•°é‡ï¼š</label>
                <input id="start-ai-count" type="number" min="0" max="3" value="1" />
            </div>
            <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
            <button id="start-settings-btn">è®¾ç½®</button>
            <button id="start-maker-btn">åˆ¶ä½œäºº</button>
        </div>
    </div>
    <div id="maker-modal" style="display:none;">
        <div id="maker-panel">
            <div class="maker-title">åˆ¶ä½œäºº</div>
            <div class="maker-name">åˆ˜æµ·é¾™çˆ¸çˆ¸</div>
            <button class="maker-btn" onclick="document.getElementById('maker-modal').style.display='none'">å…³é—­</button>
        </div>
    </div>
    <div id="custom-cursor">
        <div class="cursor-dot"></div>
        <div class="cursor-cross"></div>
        <div class="cursor-cross-h"></div>
    </div>
    <script src="phaser.min.js"></script>
    <script>
        const MAP_SIZE = 30; // 30x30
        const TILE_SIZE = 30; // æ¯æ ¼30åƒç´ 
        const TILE_COLOR = 0xaaaaaa; // åœ°å›¾åº•è‰²
        const OBSTACLE_COLOR = 0x444444; // éšœç¢ç‰©é¢œè‰²
        let obstacles = [];
        let obstacleMap = [];

        function getGameSize() {
            const minEdge = Math.min(window.innerWidth, window.innerHeight);
            const size = Math.floor(minEdge * 0.95);
            return {
                width: size,
                height: size,
                scale: size / (MAP_SIZE * TILE_SIZE)
            };
        }

        let game, scaleInfo;
        let tank, tankX, tankY, cursors, wasdKeys, barrel;
        let globalMouse = { x: 0, y: 0 };
        let bullets = [];
        const BULLET_SPEED = 7.2;
        const BULLET_RADIUS = TILE_SIZE * 0.18;
        let BULLET_COLOR = 0xffff00;
        let glowColor = 0x99ff99;
        const BULLET_LIFETIME = 3000; // å­å¼¹æœ€å¤§å­˜æ´»æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰

        // ç©å®¶å±æ€§
        let playerName = "ä¸»ç©å®¶1";
        let playerMaxHp = 100;
        let playerHp = 100;
        let playerHitCount = 0;
        let playerInvincible = false;
        let playerInvincibleTimer = 0;
        const PLAYER_MAX_HIT = 5;
        const PLAYER_INVINCIBLE_TIME = 1000; // 1ç§’

        let nightMode = false;
        let flashlightActive = false;
        let flashlightTimer = 0;
        let flashlightItems = [];
        let nightMaskGraphics;
        let FLASHLIGHT_DURATION = 25000; // 25ç§’
        let FLASHLIGHT_RADIUS = TILE_SIZE * 3.2;
        let FLASHLIGHT_RADIUS_BIG = TILE_SIZE * 7.5;
        let FLASHLIGHT_COLOR = 0xffff66;

        // å…¨å±€å˜é‡å£°æ˜åŒºï¼Œç¡®ä¿åªå£°æ˜ä¸€æ¬¡ä¸”åœ¨æ‰€æœ‰å‡½æ•°å¤–éƒ¨
        let tankColor = 0x339933;
        let aiCount = 1;
        let aiTanks = [];
        const AI_COLORS = [0x3366cc, 0xcc3333, 0xccaa33];
        let redFlashTimer = 0;
        let winnerShown = false;
        const AI_MAX_HIT = 5;
        const AI_INVINCIBLE_TIME = 1000;
        let playerInvincibleTime = 0;
        let playerHealTime = 0;
        let aiInvincibleTime = [];
        let aiHealTime = [];
        let itemList = [];
        const ITEM_TYPES = ['heal', 'invincible'];
        const ITEM_COLORS = { heal: 0x33ff33, invincible: 0x33ccff };
        const ITEM_ICON = { heal: 'ğŸ’Š', invincible: 'ğŸ›¡ï¸' };
        const HEAL_AMOUNT = 20;
        const INVINCIBLE_DURATION = 5000;

        let resizeListenerBound = false;
        let centerInterval = null;
        let creatingGame = false;
        async function createGame(pixelArt = false, antialias = true) {
            if (creatingGame) return;
            creatingGame = true;
            scaleInfo = getGameSize();
            if (game) {
                try { game.destroy(true); } catch(e) {}
                game = null;
                // æ¸…ç† .map-wrapper ä¸‹æ‰€æœ‰canvaså’Œå­èŠ‚ç‚¹
                const mw = document.querySelector('.map-wrapper');
                if (mw) {
                    while (mw.firstChild) mw.removeChild(mw.firstChild);
                }
                // ç­‰å¾…ä¸€å¸§ï¼Œç¡®ä¿èµ„æºé‡Šæ”¾
                await new Promise(res => setTimeout(res, 100));
            }
            game = new Phaser.Game({
                type: Phaser.AUTO,
                width: MAP_SIZE * TILE_SIZE,
                height: MAP_SIZE * TILE_SIZE,
                parent: document.querySelector('.map-wrapper'),
                backgroundColor: "#333",
                scale: {
                    mode: Phaser.Scale.NONE,
                    autoCenter: Phaser.Scale.CENTER_BOTH
                },
                render: {
                    pixelArt,
                    antialias
                },
                scene: {
                    create,
                    update
                }
            });
            creatingGame = false;
            // åªç»‘å®šä¸€æ¬¡resizeå’Œå±…ä¸­å®šæ—¶å™¨
            if (!resizeListenerBound) {
                window.addEventListener('resize', safeUpdateMapWrapperCenter);
                resizeListenerBound = true;
            }
            if (centerInterval) clearInterval(centerInterval);
            centerInterval = setInterval(safeUpdateMapWrapperCenter, 200);
            setTimeout(safeUpdateMapWrapperCenter, 500);
        }

        // ä¼˜åŒ–åœ°å›¾å±…ä¸­è°ƒç”¨æ—¶æœºï¼Œé˜²æ­¢DOMæœªæ¸²æŸ“æ—¶å‡ºé”™
        function updateMapWrapperCenter() {
            const playerPanel = document.getElementById('player-panel');
            const mapWrapper = document.querySelector('.map-wrapper');
            if (!playerPanel || !mapWrapper) return;
            const panelRect = playerPanel.getBoundingClientRect();
            const mapRect = mapWrapper.getBoundingClientRect();
            const winW = window.innerWidth;
            // è®¡ç®—å·¦ä¾§é¢æ¿å®½åº¦
            const leftWidth = panelRect.width;
            // è®©åœ°å›¾æ•´ä½“å±…ä¸­
            const mapWidth = mapRect.width;
            // ç›®æ ‡åœ°å›¾å·¦è¾¹è· = (çª—å£å®½åº¦ - åœ°å›¾å®½åº¦) / 2 - å·¦ä¾§é¢æ¿å®½åº¦ / 2
            const marginLeft = Math.max(0, (winW - mapWidth) / 2 - leftWidth / 2);
            mapWrapper.style.marginLeft = marginLeft + 'px';
        }
        function safeUpdateMapWrapperCenter() {
            try { updateMapWrapperCenter(); } catch(e) {}
        }

        function create() {
            // ç”Ÿæˆéšœç¢ç‰©åœ°å›¾ï¼ˆäºŒç»´æ•°ç»„ï¼‰
            obstacleMap = [];
            for (let y = 0; y < MAP_SIZE; y++) {
                const row = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    // è¾¹ç¼˜ä¸€åœˆéšœç¢ç‰©
                    if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) {
                        row.push(1);
                    } else {
                        row.push(0);
                    }
                }
                obstacleMap.push(row);
            }
            // éšæœºç”Ÿæˆå†…éƒ¨éšœç¢ç‰©ï¼Œä¿è¯å¦å…‹å‡ºç”Ÿç‚¹å’Œå‘¨å›´æœ‰è·¯
            const safeZone = 2; // å¦å…‹å‡ºç”Ÿç‚¹å‘¨å›´2æ ¼å®‰å…¨
            for (let y = 1; y < MAP_SIZE - 1; y++) {
                for (let x = 1; x < MAP_SIZE - 1; x++) {
                    // å‡ºç”Ÿç‚¹åŠå…¶å‘¨å›´ä¸æ”¾éšœç¢ç‰©
                    if (Math.abs(x - MAP_SIZE / 2) <= safeZone && Math.abs(y - MAP_SIZE / 2) <= safeZone) continue;
                    // éšæœºç”Ÿæˆéšœç¢ç‰©ï¼Œæ¦‚ç‡é€‚ä¸­
                    if (Math.random() < 0.13) {
                        // é¿å…å½¢æˆæ­»è·¯ï¼šåªåœ¨ä¸Šä¸‹å·¦å³æœ‰ç©ºæ ¼æ—¶æ”¾ç½®
                        let emptyAround = 0;
                        if (obstacleMap[y-1][x] === 0) emptyAround++;
                        if (obstacleMap[y+1][x] === 0) emptyAround++;
                        if (obstacleMap[y][x-1] === 0) emptyAround++;
                        if (obstacleMap[y][x+1] === 0) emptyAround++;
                        if (emptyAround >= 2) {
                            row = obstacleMap[y];
                            row[x] = 1;
                        }
                    }
                }
            }
            // æ¸²æŸ“æ— ç¼éš™ç°è‰²å¤§åœ°å›¾
            obstacles = [];
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    // åœ°å›¾åº•è‰²
                    this.add.rectangle(
                        x * TILE_SIZE + TILE_SIZE / 2,
                        y * TILE_SIZE + TILE_SIZE / 2,
                        TILE_SIZE,
                        TILE_SIZE,
                        TILE_COLOR
                    );
                    // éšœç¢ç‰©
                    if (obstacleMap[y][x] === 1) {
                        const obs = this.add.rectangle(
                            x * TILE_SIZE + TILE_SIZE / 2,
                            y * TILE_SIZE + TILE_SIZE / 2,
                            TILE_SIZE,
                            TILE_SIZE,
                            OBSTACLE_COLOR
                        ).setOrigin(0.5);
                        this.physics && this.physics.add && this.physics.add.existing(obs, true); // å…¼å®¹æœªæ¥ç‰©ç†
                        obstacles.push({ x, y, rect: obs });
                    }
                }
            }
            // è®°å½•éšœç¢ç‰©åƒç´ åæ ‡ï¼Œä¾¿äºç¢°æ’æ£€æµ‹
            obstacles.forEach(o => {
                o.left = o.x * TILE_SIZE;
                o.right = o.left + TILE_SIZE;
                o.top = o.y * TILE_SIZE;
                o.bottom = o.top + TILE_SIZE;
            });

            // å¦å…‹å‚æ•°
            const tankBodySize = TILE_SIZE * 0.8; // æœºèº«å®½é«˜
            const tankBarrelWidth = TILE_SIZE * 0.2; // ç‚®ç®¡å®½
            const tankBarrelLength = TILE_SIZE * 0.9; // ç‚®ç®¡é•¿ï¼Œå¤–éƒ¨æ›´é•¿
            let barrelColor = 0x222222;

            // å¦å…‹åˆå§‹ä½ç½®ï¼ˆåœ°å›¾ä¸­å¤®ï¼‰
            tankX = (MAP_SIZE / 2) * TILE_SIZE;
            tankY = (MAP_SIZE / 2) * TILE_SIZE;
            tank = this.add.container(tankX, tankY);

            // æœºèº«ï¼ˆå¤§çŸ©å½¢ï¼‰
            const body = this.add.rectangle(0, 0, tankBodySize, tankBodySize, tankColor, 1).setOrigin(0.5);
            body.name = 'player-body';
            // æ³›å…‰æ•ˆæœï¼šå‘å…‰æè¾¹
            body.setStrokeStyle(6, glowColor, 0.7);
            body.setShadow && body.setShadow(0, 0, phaserColorToHex(glowColor), 12, true, true);
            // ç‚®ç®¡originè®¾ä¸º(0.5, 1)ï¼Œåº•éƒ¨åœ¨æœºèº«ä¸­å¿ƒ
            barrel = this.add.rectangle(0, 0, tankBarrelWidth, tankBarrelLength, barrelColor, 1).setOrigin(0.5, 1);
            barrel.name = 'player-barrel';
            // ç‚®ç®¡æ³›å…‰
            barrel.setStrokeStyle(4, glowColor, 0.6);
            barrel.setShadow && barrel.setShadow(0, 0, phaserColorToHex(glowColor), 10, true, true);

            // æ·»åŠ åˆ°å¦å…‹ç»„
            tank.add([body, barrel]);
            // æ–¹ä¾¿åç»­æ§åˆ¶ï¼štank.list[0]æ˜¯æœºèº«ï¼Œtank.list[1]æ˜¯ç‚®ç®¡

            // WASDæŒ‰é”®ç›‘å¬
            wasdKeys = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // å¢å¼ºè¾“å…¥ä½“éªŒï¼šçª—å£å¤±ç„¦æ—¶é‡ç½®WASDçŠ¶æ€ï¼Œé˜²æ­¢å¡é”®
            window.addEventListener('blur', () => {
                if (wasdKeys) {
                    wasdKeys.up.isDown = false;
                    wasdKeys.down.isDown = false;
                    wasdKeys.left.isDown = false;
                    wasdKeys.right.isDown = false;
                }
            });

            // ç›‘å¬å…¨å±€é¼ æ ‡ç§»åŠ¨ï¼Œè®°å½•çœŸå®åæ ‡
            window.addEventListener('mousemove', function(e) {
                globalMouse.x = e.clientX;
                globalMouse.y = e.clientY;
            });

            // ç¼©æ”¾ç”»å¸ƒä»¥é€‚åº”çª—å£
            this.scale.displaySize.setAspectRatio(1);
            this.scale.refresh();
            const canvas = this.sys.game.canvas;
            canvas.style.width = scaleInfo.width + "px";
            canvas.style.height = scaleInfo.height + "px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";

            // é¼ æ ‡å·¦é”®å‘å°„å­å¼¹
            this.input.on('pointerdown', (pointer) => {
                if (pointer.leftButtonDown()) {
                    // è®¡ç®—ç‚®ç®¡æœ«ç«¯ä¸–ç•Œåæ ‡
                    const angle = barrel.rotation;
                    // ç‚®ç®¡æœ«ç«¯ç›¸å¯¹å¦å…‹ä¸­å¿ƒçš„åç§»
                    const offset = (TILE_SIZE * 0.9);
                    const endX = tank.x + Math.sin(angle) * offset;
                    const endY = tank.y - Math.cos(angle) * offset;
                    // æ£€æŸ¥æœ«ç«¯æ˜¯å¦åœ¨éšœç¢ç‰©å†…
                    let blocked = false;
                    for (const o of obstacles) {
                        if (
                            endX > o.left && endX < o.right &&
                            endY > o.top && endY < o.bottom
                        ) {
                            blocked = true;
                            break;
                        }
                    }
                    if (blocked) return; // åœ¨éšœç¢ç‰©å†…ä¸å‘å°„
                    // å­å¼¹é€Ÿåº¦åˆ†é‡
                    const vx = Math.sin(angle) * BULLET_SPEED;
                    const vy = -Math.cos(angle) * BULLET_SPEED;
                    // åˆ›å»ºå­å¼¹
                    const bullet = this.add.circle(endX, endY, BULLET_RADIUS, BULLET_COLOR, 1);
                    // å­å¼¹æ³›å…‰
                    bullet.setStrokeStyle(3, glowColor, 0.8);
                    bullet.setShadow && bullet.setShadow(0, 0, phaserColorToHex(glowColor), 12, true, true);
                    bullets.push({ sprite: bullet, vx, vy, fromAI: false, shooter: 'player' });
                }
            });

            // ç©å®¶å±æ€§UIæ”¾å·¦ä¾§ç©ºç™½åŒº
            // ç§»é™¤Phaserå†…çš„åå­—å’Œè¡€é‡æ¡ç›¸å…³ä»£ç 

            // é»‘å¤œé®ç½©
            if (nightMode) {
                nightMaskGraphics = this.add.graphics({ x: 0, y: 0 });
                nightMaskGraphics.setDepth(1000);
            } else {
                nightMaskGraphics = null;
            }

            // éšæœºç”Ÿæˆæ‰‹ç”µç­’é“å…·
            flashlightItems = [];
            if (nightMode) {
                for (let i = 0; i < 4; i++) {
                    let placed = false;
                    while (!placed) {
                        let fx = Phaser.Math.Between(2, MAP_SIZE - 3);
                        let fy = Phaser.Math.Between(2, MAP_SIZE - 3);
                        // ä¸ç”Ÿæˆåœ¨éšœç¢ç‰©æˆ–å‡ºç”Ÿç‚¹é™„è¿‘
                        if (obstacleMap[fy][fx] === 0 && (Math.abs(fx - MAP_SIZE/2) > 2 || Math.abs(fy - MAP_SIZE/2) > 2)) {
                            let item = this.add.circle(
                                fx * TILE_SIZE + TILE_SIZE/2,
                                fy * TILE_SIZE + TILE_SIZE/2,
                                TILE_SIZE * 0.28,
                                FLASHLIGHT_COLOR,
                                1
                            ).setDepth(900);
                            flashlightItems.push(item);
                            placed = true;
                        }
                    }
                }
            }

            // ç”ŸæˆAIå¦å…‹
            aiTanks = [];
            for (let i = 0; i < aiCount; i++) {
                // éšæœºç”Ÿæˆåœ¨å®‰å…¨åŒºå¤–çš„ç©ºåœ°
                let placed = false;
                let ax, ay;
                while (!placed) {
                    ax = Phaser.Math.Between(2, MAP_SIZE - 3);
                    ay = Phaser.Math.Between(2, MAP_SIZE - 3);
                    if (obstacleMap[ay][ax] === 0 && (Math.abs(ax - MAP_SIZE/2) > 2 || Math.abs(ay - MAP_SIZE/2) > 2)) {
                        placed = true;
                    }
                }
                let tankX = ax * TILE_SIZE + TILE_SIZE/2;
                let tankY = ay * TILE_SIZE + TILE_SIZE/2;
                let color = AI_COLORS[i % AI_COLORS.length];
                let aiTank = this.add.container(tankX, tankY);
                let body = this.add.rectangle(0, 0, TILE_SIZE * 0.8, TILE_SIZE * 0.8, color, 1).setOrigin(0.5);
                body.setStrokeStyle(6, 0xffffff, 0.5);
                let barrel = this.add.rectangle(0, 0, TILE_SIZE * 0.2, TILE_SIZE * 0.9, 0x222222, 1).setOrigin(0.5, 1);
                barrel.setStrokeStyle(4, 0xffffff, 0.4);
                aiTank.add([body, barrel]);
                aiTank.body = body;
                aiTank.barrel = barrel;
                aiTank.ai = { target: null, fireCooldown: 0, vx: 0, vy: 0 };
                aiTank.aiColor = color;
                aiTanks.push(aiTank);
            }
            // AIè¡€é‡å’Œæ— æ•ŒçŠ¶æ€
            for (let i = 0; i < aiTanks.length; i++) {
                aiTanks[i].hitCount = 0;
                aiTanks[i].invincible = false;
                aiTanks[i].invincibleTimer = 0;
            }
            playerAlive = true;
            aiAlive = Array(aiCount).fill(true);
            aiInvincibleTime = Array(aiCount).fill(0);
            aiHealTime = Array(aiCount).fill(0);
            // è®°å½•æ‰€æœ‰å‡ºç”Ÿç‚¹
            let spawnPoints = [];
            // ç©å®¶å‡ºç”Ÿç‚¹
            spawnPoints.push({ x: Math.floor(MAP_SIZE/2), y: Math.floor(MAP_SIZE/2) });
            // AIå‡ºç”Ÿç‚¹
            for (let i = 0; i < aiCount; i++) {
                let ax, ay, safe = false;
                while (!safe) {
                    ax = Phaser.Math.Between(2, MAP_SIZE - 3);
                    ay = Phaser.Math.Between(2, MAP_SIZE - 3);
                    safe = true;
                    for (let sp of spawnPoints) {
                        if (Math.abs(ax - sp.x) <= 2 && Math.abs(ay - sp.y) <= 2) { safe = false; break; }
                    }
                    if (safe) spawnPoints.push({ x: ax, y: ay });
                }
            }
            // æ¸…ç©ºå‡ºç”Ÿç‚¹åŠå…¶å‘¨å›´2æ ¼çš„éšœç¢ç‰©
            for (let sp of spawnPoints) {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        let tx = sp.x + dx, ty = sp.y + dy;
                        if (tx >= 0 && tx < MAP_SIZE && ty >= 0 && ty < MAP_SIZE) {
                            obstacleMap[ty][tx] = 0;
                        }
                    }
                }
            }
            // éšæœºç”Ÿæˆé“å…·
            itemList = [];
            for (let i = 0; i < 3; i++) {
                let placed = false;
                while (!placed) {
                    let fx = Phaser.Math.Between(2, MAP_SIZE - 3);
                    let fy = Phaser.Math.Between(2, MAP_SIZE - 3);
                    // ä¸ç”Ÿæˆåœ¨å‡ºç”Ÿå®‰å…¨åŒº
                    let safe = true;
                    for (let sp of spawnPoints) {
                        if (Math.abs(fx - sp.x) <= 2 && Math.abs(fy - sp.y) <= 2) { safe = false; break; }
                    }
                    if (obstacleMap[fy][fx] === 0 && safe) {
                        let type = ITEM_TYPES[Math.floor(Math.random()*ITEM_TYPES.length)];
                        let item = this.add.circle(
                            fx * TILE_SIZE + TILE_SIZE/2,
                            fy * TILE_SIZE + TILE_SIZE/2,
                            TILE_SIZE * 0.28,
                            ITEM_COLORS[type],
                            1
                        ).setDepth(900);
                        item.setData('type', type);
                        itemList.push(item);
                        placed = true;
                    }
                }
            }
        }

        function update() {
            if (gamePaused) return;
            if (!tank) return;
            if (!playerAlive) {
                if (wasdKeys) {
                    wasdKeys.up.isDown = false;
                    wasdKeys.down.isDown = false;
                    wasdKeys.left.isDown = false;
                    wasdKeys.right.isDown = false;
                }
                return;
            }
            let speed = 3 * scaleInfo.scale; // è‡ªé€‚åº”ç¼©æ”¾ä¸‹çš„é€Ÿåº¦
            let moved = false;
            let nextX = tankX, nextY = tankY;
            if (wasdKeys.left.isDown) {
                nextX -= speed;
                moved = true;
            }
            if (wasdKeys.right.isDown) {
                nextX += speed;
                moved = true;
            }
            if (wasdKeys.up.isDown) {
                nextY -= speed;
                moved = true;
            }
            if (wasdKeys.down.isDown) {
                nextY += speed;
                moved = true;
            }
            // è¾¹ç•Œé™åˆ¶
            const half = TILE_SIZE * 0.8 / 2;
            const min = half;
            const max = MAP_SIZE * TILE_SIZE - half;
            nextX = Phaser.Math.Clamp(nextX, min, max);
            nextY = Phaser.Math.Clamp(nextY, min, max);
            // ç¢°æ’æ£€æµ‹ï¼šå¦å…‹æœºèº«ä¸éšœç¢ç‰©
            let collide = false;
            for (const o of obstacles) {
                if (
                    nextX + half > o.left && nextX - half < o.right &&
                    nextY + half > o.top && nextY - half < o.bottom
                ) {
                    collide = true;
                    break;
                }
            }
            if (!collide) {
                tankX = nextX;
                tankY = nextY;
                if (moved) {
                    tank.x = tankX;
                    tank.y = tankY;
                }
            } else if (moved) {
                // è´´å¢™æ»‘åŠ¨ï¼šåˆ†åˆ«å°è¯•åªç§»åŠ¨xæˆ–åªç§»åŠ¨y
                let tryX = true, tryY = true;
                // åªç§»åŠ¨x
                let collideX = false;
                for (const o of obstacles) {
                    if (
                        nextX + half > o.left && nextX - half < o.right &&
                        tankY + half > o.top && tankY - half < o.bottom
                    ) {
                        collideX = true;
                        break;
                    }
                }
                // åªç§»åŠ¨y
                let collideY = false;
                for (const o of obstacles) {
                    if (
                        tankX + half > o.left && tankX - half < o.right &&
                        nextY + half > o.top && nextY - half < o.bottom
                    ) {
                        collideY = true;
                        break;
                    }
                }
                // å¦‚æœåªç§»åŠ¨xä¸ç¢°æ’ï¼Œå…è®¸xæ–¹å‘æ»‘åŠ¨
                if (!collideX) {
                    tankX = nextX;
                    tank.x = tankX;
                }
                // å¦‚æœåªç§»åŠ¨yä¸ç¢°æ’ï¼Œå…è®¸yæ–¹å‘æ»‘åŠ¨
                if (!collideY) {
                    tankY = nextY;
                    tank.y = tankY;
                }
            }
            // é¼ æ ‡æ§åˆ¶ç‚®ç®¡æ—‹è½¬ï¼ˆä¿®æ­£ç‰ˆï¼‰
            const canvas = game.canvas;
            const rect = canvas.getBoundingClientRect();
            const scale = scaleInfo.scale;
            // é¼ æ ‡åœ¨canvaså†…çš„é€»è¾‘åæ ‡
            const mouseX = (globalMouse.x - rect.left) / scale;
            const mouseY = (globalMouse.y - rect.top) / scale;
            // è®¡ç®—è§’åº¦ï¼ˆæœºèº«ä¸­å¿ƒåˆ°é¼ æ ‡ï¼‰
            const angle = Phaser.Math.Angle.Between(tankX, tankY, mouseX, mouseY);
            barrel.rotation = angle + Math.PI / 2;

            const now = Date.now();
            // å­å¼¹ç§»åŠ¨ä¸æ¸…ç†
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.sprite.x += b.vx;
                b.sprite.y += b.vy;
                // å­å¼¹åå¼¹æ£€æµ‹
                let reflected = false;
                for (const o of obstacles) {
                    // ç²—ç•¥AABBç¢°æ’
                    if (
                        b.sprite.x + BULLET_RADIUS > o.left && b.sprite.x - BULLET_RADIUS < o.right &&
                        b.sprite.y + BULLET_RADIUS > o.top && b.sprite.y - BULLET_RADIUS < o.bottom
                    ) {
                        // åˆ¤æ–­æ˜¯æ°´å¹³è¿˜æ˜¯å‚ç›´åå¼¹
                        const prevX = b.sprite.x - b.vx;
                        const prevY = b.sprite.y - b.vy;
                        if (
                            prevX + BULLET_RADIUS <= o.left || prevX - BULLET_RADIUS >= o.right
                        ) {
                            b.vx = -b.vx; // æ°´å¹³åå¼¹
                            reflected = true;
                        }
                        if (
                            prevY + BULLET_RADIUS <= o.top || prevY - BULLET_RADIUS >= o.bottom
                        ) {
                            b.vy = -b.vy; // å‚ç›´åå¼¹
                            reflected = true;
                        }
                        if (reflected) {
                            // åå¼¹åå°†å­å¼¹æ¨ç¦»éšœç¢ç‰©ï¼Œé¿å…å¡ä½
                            b.sprite.x += b.vx;
                            b.sprite.y += b.vy;
                        }
                        break;
                    }
                }
                // è¶…å‡ºåœ°å›¾è¾¹ç•Œåˆ™é”€æ¯
                if (
                    b.sprite.x < 0 || b.sprite.x > MAP_SIZE * TILE_SIZE ||
                    b.sprite.y < 0 || b.sprite.y > MAP_SIZE * TILE_SIZE
                ) {
                    b.sprite.destroy();
                    bullets.splice(i, 1);
                    continue;
                }
                // å­å¼¹é£è¡Œè¶…æ—¶è‡ªåŠ¨æ¶ˆå¤±
                if (!b.birth) b.birth = now;
                if (now - b.birth > BULLET_LIFETIME) {
                    b.sprite.destroy();
                    bullets.splice(i, 1);
                }
            }

            // AIå¦å…‹åŸºç¡€è¡Œä¸º
            for (let i = 0; i < aiTanks.length; i++) {
                if (!aiAlive[i]) continue;
                let ai = aiTanks[i];
                // å¦‚æœAIå‡ºç”Ÿç‚¹è¢«éšœç¢ç‰©è¦†ç›–ï¼Œå¼ºåˆ¶ç§»åˆ°æœ€è¿‘ç©ºåœ°
                let ax = Math.round(ai.x / TILE_SIZE), ay = Math.round(ai.y / TILE_SIZE);
                if (obstacleMap[ay] && obstacleMap[ay][ax] === 1) {
                    // æ‰¾æœ€è¿‘ç©ºåœ°
                    let found = false;
                    for (let r = 1; r < 5 && !found; r++) {
                        for (let dx = -r; dx <= r; dx++) {
                            for (let dy = -r; dy <= r; dy++) {
                                let tx = ax + dx, ty = ay + dy;
                                if (tx >= 0 && tx < MAP_SIZE && ty >= 0 && ty < MAP_SIZE && obstacleMap[ty][tx] === 0) {
                                    ai.x = tx * TILE_SIZE + TILE_SIZE/2;
                                    ai.y = ty * TILE_SIZE + TILE_SIZE/2;
                                    found = true;
                                    break;
                                }
                            }
                            if (found) break;
                        }
                    }
                }
                // åªæœ‰è¡€é‡ä½äº40æ—¶æ‰ä¼šä¸»åŠ¨æ¡é“å…·
                let target = null;
                if ((ai.hitCount / AI_MAX_HIT) > 0.6) {
                    let nearestItem = null, minItemDist = 1e9;
                    for (let item of itemList) {
                        let dx = ai.x - item.x, dy = ai.y - item.y;
                        let d = dx*dx + dy*dy;
                        // åªè€ƒè™‘è·ç¦»è‡ªå·±æœ€è¿‘ä¸”æ²¡æœ‰å…¶ä»–AIæ›´è¿‘çš„é“å…·
                        let closest = true;
                        for (let k = 0; k < aiTanks.length; k++) {
                            if (k !== i && aiAlive[k]) {
                                let adx = aiTanks[k].x - item.x, ady = aiTanks[k].y - item.y;
                                let ad = adx*adx + ady*ady;
                                if (ad < d) { closest = false; break; }
                            }
                        }
                        if (closest && d < minItemDist) { minItemDist = d; nearestItem = item; }
                    }
                    if (nearestItem && minItemDist < Math.pow(TILE_SIZE*10,2)) {
                        target = { x: nearestItem.x, y: nearestItem.y };
                    }
                }
                if (!target) {
                    // é€‰æ‹©æœ€è¿‘çš„æ´»ç€ç›®æ ‡ï¼ˆç©å®¶æˆ–å…¶ä»–AIï¼Œä¸èƒ½é€‰è‡ªå·±ï¼‰
                    let candidates = [];
                    if (playerAlive) candidates.push({ x: tankX, y: tankY, isPlayer: true, idx: -1, hit: playerHitCount });
                    for (let j = 0; j < aiTanks.length; j++) {
                        if (j !== i && aiAlive[j]) candidates.push({ x: aiTanks[j].x, y: aiTanks[j].y, isPlayer: false, idx: j, hit: aiTanks[j].hitCount||0 });
                    }
                    // ä¼˜å…ˆæ”»å‡»è¡€é‡æœ€ä½çš„æ•Œäººï¼Œå¶å°”åä½œå¤¹å‡»ç©å®¶
                    let minHit = Math.min(...candidates.map(c=>c.hit));
                    let minHitCandidates = candidates.filter(c=>c.hit===minHit);
                    let t = null;
                    if (Math.random()<0.2 && playerAlive) {
                        // 20%æ¦‚ç‡ä¼˜å…ˆå¤¹å‡»ç©å®¶
                        t = candidates.find(c=>c.isPlayer);
                    }
                    if (!t) {
                        // å…¶ä½™æƒ…å†µä¼˜å…ˆæ”»å‡»è¡€é‡æœ€ä½çš„æ•Œäºº
                        let minDist = 1e9;
                        for (let c of minHitCandidates) {
                            let dx = c.x - ai.x, dy = c.y - ai.y;
                            let d = dx*dx + dy*dy;
                            if (d < minDist) { minDist = d; t = c; }
                        }
                    }
                    target = t;
                }
                if (!target || typeof target.x !== 'number' || typeof target.y !== 'number') continue;
                // --- AIåŠ¨æ€ç­–ç•¥åˆ‡æ¢ ---
                // è®°å½•ç›®æ ‡ä¸Šä¸€æ¬¡ä½ç½®ï¼Œé¢„æµ‹æœªæ¥ä½ç½®
                if (!ai.lastTargetPos) ai.lastTargetPos = { x: target.x, y: target.y };
                let vx = target.x - ai.lastTargetPos.x;
                let vy = target.y - ai.lastTargetPos.y;
                ai.lastTargetPos = { x: target.x, y: target.y };
                let dx = target.x - ai.x, dy = target.y - ai.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let bulletTime = dist / BULLET_SPEED;
                let predX = target.x + vx * bulletTime;
                let predY = target.y + vy * bulletTime;
                // --- AIçŠ¶æ€å†³ç­– ---
                let aiMode = 'attack';
                if ((ai.hitCount / AI_MAX_HIT) > 0.6) {
                    // è¡€é‡ä½ï¼Œä¼˜å…ˆè¡¥ç»™/é€ƒè·‘
                    aiMode = 'heal';
                } else if (dist < TILE_SIZE * 3) {
                    // è·ç¦»è¿‡è¿‘ï¼Œä¼˜å…ˆè§„é¿
                    aiMode = 'evade';
                }
                // --- AIç§»åŠ¨å†³ç­– ---
                let speed = 2 * scaleInfo.scale;
                let moveX = 0, moveY = 0;
                let half = TILE_SIZE * 0.8 / 2;
                if (aiMode === 'heal') {
                    // è¿œç¦»æ•Œäºº/é è¿‘è¡¥ç»™
                    let bestItem = null, minItemDist = 1e9;
                    for (let item of itemList) {
                        let d = (ai.x-item.x)**2 + (ai.y-item.y)**2;
                        if (d < minItemDist) { minItemDist = d; bestItem = item; }
                    }
                    if (bestItem) {
                        let idx = Math.atan2(bestItem.y-ai.y, bestItem.x-ai.x);
                        moveX = Math.cos(idx) * speed;
                        moveY = Math.sin(idx) * speed;
                    } else {
                        // è¿œç¦»ç›®æ ‡
                        let away = Math.atan2(ai.y-target.y, ai.x-target.x);
                        moveX = Math.cos(away) * speed;
                        moveY = Math.sin(away) * speed;
                    }
                } else if (aiMode === 'evade') {
                    // ä¾§ç§»æˆ–åé€€
                    let away = Math.atan2(ai.y-target.y, ai.x-target.x);
                    moveX = Math.cos(away+Math.PI/2) * speed;
                    moveY = Math.sin(away+Math.PI/2) * speed;
                } else {
                    // æ”»å‡»æ¨¡å¼ï¼Œé è¿‘ç›®æ ‡
                    // --- éšœç¢ç»•è¡Œå‡çº§ï¼šè®°å¿†ç‚¹ ---
                    ai.stuckCount = ai.stuckCount || 0;
                    ai.lastPos = ai.lastPos || {x:ai.x, y:ai.y};
                    if (Math.abs(ai.x-ai.lastPos.x)<1 && Math.abs(ai.y-ai.lastPos.y)<1) {
                        ai.stuckCount++;
                    } else {
                        ai.stuckCount=0;
                    }
                    ai.lastPos = {x:ai.x, y:ai.y};
                    let tryAngles = [0, Math.PI/4, -Math.PI/4, Math.PI/2, -Math.PI/2, Math.PI*3/4, -Math.PI*3/4];
                    let bestDir = null;
                    let minDist = Infinity;
                    let stuck = true;
                    for (let dtheta of tryAngles) {
                        let angle = Math.atan2(dy, dx) + dtheta;
                        let tx = ai.x + Math.cos(angle) * speed;
                        let ty = ai.y + Math.sin(angle) * speed;
                        let collide = false;
                        for (const o of obstacles) {
                            if (
                                tx + half > o.left && tx - half < o.right &&
                                ty + half > o.top && ty - half < o.bottom
                            ) { collide = true; break; }
                        }
                        if (!collide) {
                            stuck = false;
                            let distToTarget = (tx - target.x) ** 2 + (ty - target.y) ** 2;
                            let angleWeight = Math.abs(dtheta) > Math.PI/2 ? 0.7 : 1;
                            if (distToTarget * angleWeight < minDist) {
                                minDist = distToTarget * angleWeight;
                                bestDir = { moveX: tx - ai.x, moveY: ty - ai.y };
                            }
                        }
                    }
                    if (bestDir) {
                        moveX = bestDir.moveX;
                        moveY = bestDir.moveY;
                        ai.stuckCount = 0;
                    } else {
                        ai.stuckCount++;
                        if (ai.stuckCount > 20) {
                            // éšæœºå°è¯•8ä¸ªæ–¹å‘å¼ºåˆ¶è„±å›°
                            let found = false;
                            for (let k = 0; k < 8; k++) {
                                let randAngle = Math.random() * Math.PI * 2;
                                let tx = ai.x + Math.cos(randAngle) * speed;
                                let ty = ai.y + Math.sin(randAngle) * speed;
                                let collide = false;
                                for (const o of obstacles) {
                                    if (tx + half > o.left && tx - half < o.right && ty + half > o.top && ty - half < o.bottom) {
                                        collide = true; break;
                                    }
                                }
                                if (!collide) {
                                    moveX = tx - ai.x;
                                    moveY = ty - ai.y;
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) { moveX = 0; moveY = 0; }
                        } else if (ai.stuckCount > 10) {
                            let backAngle = Math.atan2(dy, dx) + Math.PI;
                            moveX = Math.cos(backAngle) * speed;
                            moveY = Math.sin(backAngle) * speed;
                        }
                    }
                }
                ai.x += moveX;
                ai.y += moveY;
                // --- AIé¢„åˆ¤å°„å‡» ---
                ai.ai.fireCooldown--;
                if (ai.ai.fireCooldown <= 0 && dist < TILE_SIZE * 10) {
                    // é¢„åˆ¤ç›®æ ‡æœªæ¥ä½ç½®
                    let shootAngle = Phaser.Math.Angle.Between(ai.x, ai.y, predX, predY) + Phaser.Math.FloatBetween(-0.12, 0.12) + Math.PI/2;
                    let offset = TILE_SIZE * 0.9;
                    let endX = ai.x + Math.sin(shootAngle) * offset;
                    let endY = ai.y - Math.cos(shootAngle) * offset;
                    // æ£€æŸ¥éšœç¢ç‰©
                    let blocked = false;
                    for (const o of obstacles) {
                        if (endX > o.left && endX < o.right && endY > o.top && endY < o.bottom) {
                            blocked = true; break;
                        }
                    }
                    if (!blocked) {
                        let bullet = ai.scene.add.circle(endX, endY, BULLET_RADIUS, ai.aiColor, 1);
                        bullet.setStrokeStyle(3, glowColor, 0.8);
                        bullet.setShadow && bullet.setShadow(0, 0, phaserColorToHex(glowColor), 12, true, true);
                        let vx = Math.sin(shootAngle) * BULLET_SPEED;
                        let vy = -Math.cos(shootAngle) * BULLET_SPEED;
                        bullets.push({ sprite: bullet, vx, vy, fromAI: true, shooter: i });
                        ai.ai.fireCooldown = 30 + Math.floor(Math.random()*10); // 0.5ç§’å†·å´
                    }
                }
                // --- AIç‚®ç®¡æœå‘é¢„åˆ¤ç‚¹ ---
                let targetAngle = Phaser.Math.Angle.Between(ai.x, ai.y, predX, predY) + Math.PI/2;
                ai.barrel.rotation = Phaser.Math.Angle.RotateTo(ai.barrel.rotation, targetAngle, 0.12);
                // --- AI èº²é¿å­å¼¹ä¼˜å…ˆçº§æœ€é«˜ ---
                ai.dodgeTimer = ai.dodgeTimer || 0;
                let danger = false;
                let dodgeDir = null;
                for (let b of bullets) {
                    if (b.shooter === i) continue;
                    let bdx = ai.x - b.sprite.x, bdy = ai.y - b.sprite.y;
                    let bdist = Math.sqrt(bdx*bdx + bdy*bdy);
                    if (bdist > TILE_SIZE * 7) continue;
                    let bulletDir = Math.atan2(b.vy, b.vx);
                    let toAI = Math.atan2(bdy, bdx);
                    let angleDiff = Math.abs(Phaser.Math.Angle.Wrap(bulletDir - toAI));
                    if (angleDiff < 0.4) {
                        danger = true;
                        // ä¼˜å…ˆä¾§ç§»
                        let sideAngle1 = bulletDir + Math.PI/2;
                        let sideAngle2 = bulletDir - Math.PI/2;
                        let tryAngles = [sideAngle1, sideAngle2, bulletDir + Math.PI];
                        for (let ang of tryAngles) {
                            let tx = ai.x + Math.cos(ang) * speed * 1.2;
                            let ty = ai.y + Math.sin(ang) * speed * 1.2;
                            let collide = false;
                            for (const o of obstacles) {
                                if (
                                    tx + half > o.left && tx - half < o.right &&
                                    ty + half > o.top && ty - half < o.bottom
                                ) { collide = true; break; }
                            }
                            if (!collide) {
                                dodgeDir = { moveX: tx - ai.x, moveY: ty - ai.y };
                                break;
                            }
                        }
                        break;
                    }
                }
                if (danger && dodgeDir) {
                    ai.dodgeTimer = 10;
                }
                if (ai.dodgeTimer > 0 && dodgeDir) {
                    moveX = dodgeDir.moveX;
                    moveY = dodgeDir.moveY;
                    ai.dodgeTimer--;
                } else {
                    // --- AIåŠ¨æ€ç­–ç•¥åˆ‡æ¢ä¸ç§»åŠ¨å†³ç­–ï¼ˆåŸæœ‰ä»£ç ï¼‰ ---
                    // ...åŸæœ‰aiMode/è¡¥ç»™/é€ƒè·‘/æ”»å‡»/éšœç¢ç»•è¡Œç­‰é€»è¾‘...
                    // è¿™é‡Œä¿ç•™åŸæœ‰çš„aiModeåˆ¤æ–­å’Œç§»åŠ¨å†³ç­–
                    // ...
                }
                ai.x += moveX;
                ai.y += moveY;
            }

            // æ›´æ–°HTMLå·¦ä¾§UI
            document.getElementById('player-name').textContent = playerName;
            const hpPercent = Math.max(0, Math.min(1, playerHp / playerMaxHp));
            const hpBarFg = document.getElementById('hp-bar-fg');
            if (hpBarFg) {
                // åŠ¨æ€è¡€é‡æ¡åŠ¨ç”»
                let percent = Math.max(0, 1 - playerHitCount / PLAYER_MAX_HIT);
                hpBarFg.style.transition = 'width 0.3s cubic-bezier(.4,1.6,.6,1)';
                hpBarFg.style.width = (percent * 100) + '%';
                document.getElementById('hp-bar-value').textContent = `${Math.round(percent*100)}/100`;
            }

            // ç§»é™¤åœ°å›¾å¤´é¡¶è¡€é‡æ¡ï¼Œåªä¿ç•™å·¦ä¾§é¢æ¿
            // ä¼˜åŒ–å·¦ä¾§é¢æ¿è¡€é‡æ¡ï¼Œå¤ç”¨DOMï¼Œé˜²æ­¢æ–‡å­—æº¢å‡º
            let playerListPanel = document.getElementById('player-list-panel');
            if (!playerListPanel) {
                playerListPanel = document.createElement('div');
                playerListPanel.id = 'player-list-panel';
                playerListPanel.style.display = 'flex';
                playerListPanel.style.flexDirection = 'column';
                playerListPanel.style.alignItems = 'flex-start';
                playerListPanel.style.width = '100%';
                playerListPanel.style.marginTop = '18px';
                document.getElementById('player-panel').appendChild(playerListPanel);
            }
            // å¤ç”¨è¡€é‡æ¡DOM
            let allPlayers = [{
                name: playerName,
                hit: playerHitCount,
                maxHit: PLAYER_MAX_HIT,
                alive: playerAlive,
                isPlayer: true
            }];
            for (let i = 0; i < aiTanks.length; i++) {
                allPlayers.push({
                    name: `AI${i+1}`,
                    hit: aiTanks[i].hitCount || 0,
                    maxHit: AI_MAX_HIT,
                    alive: aiAlive[i],
                    isPlayer: false
                });
            }
            // ä¿è¯æ•°é‡ä¸€è‡´
            while (playerListPanel.children.length < allPlayers.length) {
                let wrap = document.createElement('div');
                wrap.className = 'player-bar-wrap';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.marginBottom = '8px';
                wrap.innerHTML = `
                    <span class="player-bar-label" style="min-width:38px;max-width:48px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;"></span>
                    <div class="player-bar-bar" style="width:48px;height:8px;background:#2a2a2a;border-radius:4px;border:1px solid #aa2222;overflow:hidden;margin-right:4px;flex-shrink:0;">
                        <div class="player-bar-fg" style="height:100%;background:linear-gradient(90deg,#22dd22 60%,#66ff66 100%);width:100%;transition:width 0.3s;"></div>
                    </div>
                    <span class="player-bar-num" style="font-size:11px;color:#fff;font-weight:bold;text-shadow:0 1px 2px #222,0 0 2px #fff8;min-width:36px;max-width:40px;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;"></span>
                `;
                playerListPanel.appendChild(wrap);
            }
            while (playerListPanel.children.length > allPlayers.length) {
                playerListPanel.removeChild(playerListPanel.lastChild);
            }
            for (let i = 0; i < allPlayers.length; i++) {
                let p = allPlayers[i];
                let wrap = playerListPanel.children[i];
                let label = wrap.querySelector('.player-bar-label');
                let fg = wrap.querySelector('.player-bar-fg');
                let num = wrap.querySelector('.player-bar-num');
                label.textContent = p.name;
                label.style.color = p.isPlayer ? '#fff' : '#aaf';
                fg.style.width = `${Math.max(0, (1-p.hit/p.maxHit)*100)}%`;
                num.textContent = `${Math.max(0,Math.round((1-p.hit/p.maxHit)*100))}/100`;
                wrap.style.opacity = p.alive ? '1' : '0.3';
            }

            // é»‘å¤œé®ç½©ç»˜åˆ¶
            if (nightMode && nightMaskGraphics) {
                nightMaskGraphics.clear();
                if (!flashlightActive) {
                    nightMaskGraphics.fillStyle(0x000000, 0.82);
                    nightMaskGraphics.fillRect(0, 0, MAP_SIZE * TILE_SIZE, MAP_SIZE * TILE_SIZE);
                    // è§†é‡åœ†
                    nightMaskGraphics.setBlendMode(Phaser.BlendModes.ERASE);
                    nightMaskGraphics.fillCircle(tankX, tankY, FLASHLIGHT_RADIUS);
                    nightMaskGraphics.setBlendMode(Phaser.BlendModes.NORMAL);
                }
                // flashlightActive æ—¶ä¸ç»˜åˆ¶é®ç½©ï¼Œåœ°å›¾å…¨äº®
            }

            // æ‰‹ç”µç­’é“å…·æ£€æµ‹
            if (nightMode && flashlightItems.length > 0) {
                for (let i = flashlightItems.length - 1; i >= 0; i--) {
                    let item = flashlightItems[i];
                    let dx = tankX - item.x;
                    let dy = tankY - item.y;
                    if (dx * dx + dy * dy < (TILE_SIZE * 0.5) * (TILE_SIZE * 0.5)) {
                        item.destroy();
                        flashlightItems.splice(i, 1);
                        flashlightActive = true;
                        flashlightTimer = Date.now();
                    }
                }
            }
            // æ‰‹ç”µç­’è®¡æ—¶
            if (flashlightActive && Date.now() - flashlightTimer > FLASHLIGHT_DURATION) {
                flashlightActive = false;
            }

            // é“å…·æ£€æµ‹ï¼ˆç©å®¶ï¼‰
            for (let i = itemList.length - 1; i >= 0; i--) {
                let item = itemList[i];
                let dx = tankX - item.x;
                let dy = tankY - item.y;
                if (dx * dx + dy * dy < (TILE_SIZE * 0.5) * (TILE_SIZE * 0.5)) {
                    const type = item.getData('type');
                    if (type === 'heal') {
                        playerHitCount = Math.max(0, playerHitCount - HEAL_AMOUNT);
                        playerHealTime = Date.now();
                    } else if (type === 'invincible') {
                        playerInvincible = true;
                        playerInvincibleTime = Date.now();
                    }
                    if (item.icon) { item.icon.remove(); item.icon = null; }
                    item.destroy();
                    itemList.splice(i, 1);
                }
            }
            // ç©å®¶æ— æ•ŒåŒ…è®¡æ—¶
            if (playerInvincible && playerInvincibleTime && Date.now() - playerInvincibleTime > INVINCIBLE_DURATION) {
                playerInvincible = false;
            }
            // é“å…·æ£€æµ‹ï¼ˆAIï¼‰
            for (let k = 0; k < aiTanks.length; k++) {
                if (!aiAlive[k]) continue;
                let ai = aiTanks[k];
                for (let i = itemList.length - 1; i >= 0; i--) {
                    let item = itemList[i];
                    let dx = ai.x - item.x;
                    let dy = ai.y - item.y;
                    if (dx * dx + dy * dy < (TILE_SIZE * 0.5) * (TILE_SIZE * 0.5)) {
                        const type = item.getData('type');
                        if (type === 'heal') {
                            ai.hitCount = Math.max(0, ai.hitCount - HEAL_AMOUNT);
                            aiHealTime[k] = Date.now();
                        } else if (type === 'invincible') {
                            ai.invincible = true;
                            aiInvincibleTime[k] = Date.now();
                        }
                        if (item.icon) { item.icon.remove(); item.icon = null; }
                        item.destroy();
                        itemList.splice(i, 1);
                    }
                }
                // AIæ— æ•ŒåŒ…è®¡æ—¶
                if (ai.invincible && aiInvincibleTime[k] && Date.now() - aiInvincibleTime[k] > INVINCIBLE_DURATION) {
                    ai.invincible = false;
                }
            }

            // ç©å®¶è¢«å­å¼¹å‡»ä¸­æ£€æµ‹
            if (!playerInvincible && playerAlive) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    // åªæ£€æµ‹AIå­å¼¹ï¼Œä¸”ä¸æ˜¯ç©å®¶è‡ªå·±å‘å°„çš„
                    if (!b.fromAI || b.shooter === 'player') continue;
                    let dx = tankX - b.sprite.x;
                    let dy = tankY - b.sprite.y;
                    let r = TILE_SIZE * 0.8 / 2 + BULLET_RADIUS;
                    if (dx * dx + dy * dy < r * r) {
                        playerHitCount++;
                        playerInvincible = true;
                        playerInvincibleTimer = Date.now();
                        b.sprite.destroy();
                        bullets.splice(i, 1);
                        // çº¢æ™•é—ªçƒ
                        redFlashTimer = Date.now();
                        break;
                    }
                }
            } else if (playerInvincible) {
                if (Date.now() - playerInvincibleTimer > PLAYER_INVINCIBLE_TIME) {
                    playerInvincible = false;
                }
            }
            // ç©å®¶æ­»äº¡æ£€æµ‹
            if (playerHitCount >= PLAYER_MAX_HIT && playerAlive) {
                playerAlive = false;
                // çˆ†ç‚¸ç‰¹æ•ˆ
                let boom = game.scene.scenes[0].add.circle(tankX, tankY, TILE_SIZE * 0.8, 0xffcc00, 0.7).setDepth(9999);
                boom.setStrokeStyle(8, 0xff3300, 0.8);
                game.scene.scenes[0].tweens.add({
                    targets: boom,
                    scale: 2,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => boom.destroy()
                });
                // ç²’å­é—ªå…‰
                showDeathParticles(tankX, tankY);
                // ç©å®¶å¦å…‹è‡ªåŠ¨æ¶ˆå¤±
                if (tank && tank.destroy) tank.destroy();
            }
            // AIè¢«ç©å®¶å­å¼¹å‡»ä¸­æ£€æµ‹
            for (let i = 0; i < aiTanks.length; i++) {
                if (!aiAlive[i]) continue;
                let ai = aiTanks[i];
                // AIæ— æ•Œè®¡æ—¶
                if (ai.invincible && Date.now() - ai.invincibleTimer > AI_INVINCIBLE_TIME) {
                    ai.invincible = false;
                }
                if (!ai.invincible) {
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const b = bullets[j];
                        // åªè·³è¿‡è‡ªå·±å‘å°„çš„å­å¼¹ï¼Œå…¶ä»–éƒ½èƒ½å‘½ä¸­
                        if (b.shooter === i) continue;
                        let dx = ai.x - b.sprite.x;
                        let dy = ai.y - b.sprite.y;
                        let r = TILE_SIZE * 0.8 / 2 + BULLET_RADIUS;
                        if (dx * dx + dy * dy < r * r) {
                            ai.hitCount = (ai.hitCount || 0) + 1;
                            ai.invincible = true;
                            ai.invincibleTimer = Date.now();
                            b.sprite.destroy();
                            bullets.splice(j, 1);
                            // çˆ†ç‚¸ç‰¹æ•ˆï¼ˆåªæœ‰æ­»äº¡æ—¶ï¼‰
                            if (ai.hitCount >= AI_MAX_HIT) {
                                aiAlive[i] = false;
                                let boom = ai.scene.add.circle(ai.x, ai.y, TILE_SIZE * 0.8, 0xffcc00, 0.7).setDepth(9999);
                                boom.setStrokeStyle(8, 0xff3300, 0.8);
                                ai.scene.tweens.add({
                                    targets: boom,
                                    scale: 2,
                                    alpha: 0,
                                    duration: 400,
                                    onComplete: () => boom.destroy()
                                });
                                // AIå¦å…‹è‡ªåŠ¨æ¶ˆå¤±
                                if (ai && ai.destroy) ai.destroy();
                            }
                            break;
                        }
                    }
                }
            }
            // åˆ¤æ–­èƒœåˆ©
            let aliveCount = (playerAlive ? 1 : 0) + aiAlive.filter(x=>x).length;
            if (aliveCount === 1 && !winnerShown) {
                winnerShown = true;
                setTimeout(() => {
                    let winner = playerAlive ? playerName : getAIWinnerName();
                    showWinnerModal(winner);
                }, 200);
            }
        }

        // è®¾ç½®çª—å£é€»è¾‘
        function hexToPhaserColor(hex) {
            return parseInt(hex.replace('#', '0x'));
        }
        function phaserColorToHex(num) {
            return '#' + num.toString(16).padStart(6, '0');
        }
        function setAntialiasMode(mode) {
            // ä»…èƒ½é€šè¿‡é‡å»ºgameå®ç°
            let pixelArt = (mode === 'off') ? true : false;
            let antialias = (mode === 'on');
            // è®°å½•è®¾ç½®
            localStorage.setItem('antialias', mode);
            // é‡æ–°åˆ›å»ºgame
            setTimeout(() => {
                createGame(pixelArt, antialias);
            }, 50);
        }
        function openSettings() {
            document.getElementById('settings-modal').style.display = 'flex';
            document.getElementById('name-input').value = playerName;
            document.getElementById('tank-color-input').value = phaserColorToHex(tankColor);
            document.getElementById('bullet-color-input').value = phaserColorToHex(BULLET_COLOR);
            document.getElementById('glow-color-input').value = phaserColorToHex(glowColor);
            document.getElementById('antialias-select').value = (localStorage.getItem('antialias') || 'on');
            document.getElementById('night-mode-input').checked = nightMode;
            // ç§»é™¤è®¾ç½®çª—å£AIæ•°é‡ç›¸å…³é€»è¾‘
        }
        function closeSettings() {
            document.getElementById('settings-modal').style.display = 'none';
        }
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('settings-modal');
                if (modal.style.display === 'flex') {
                    closeSettings();
                } else {
                    openSettings();
                }
            }
        });
        document.getElementById('settings-close').onclick = closeSettings;
        document.getElementById('antialias-select').onchange = function() {
            setAntialiasMode(this.value);
        };
        document.getElementById('name-input').oninput = function() {
            playerName = this.value;
        };
        document.getElementById('tank-color-input').oninput = function() {
            tankColor = hexToPhaserColor(this.value);
            // å®æ—¶æ›´æ–°å¦å…‹é¢œè‰²
            if (tank && tank.list && tank.list[0]) tank.list[0].fillColor = tankColor;
        };
        document.getElementById('bullet-color-input').oninput = function() {
            BULLET_COLOR = hexToPhaserColor(this.value);
        };
        document.getElementById('glow-color-input').oninput = function() {
            glowColor = hexToPhaserColor(this.value);
            // å®æ—¶æ›´æ–°å¦å…‹å’Œå­å¼¹æ³›å…‰é¢œè‰²
            if (tank && tank.list && tank.list[0]) tank.list[0].setStrokeStyle(6, glowColor, 0.7);
            if (tank && tank.list && tank.list[1]) tank.list[1].setStrokeStyle(4, glowColor, 0.6);
        };
        // è®¾ç½®çª—å£é»‘å¤œæ¨¡å¼å¼€å…³
        document.getElementById('night-mode-input').onchange = function() {
            nightMode = this.checked;
            createGame(
                (localStorage.getItem('antialias') || 'on') === 'off',
                (localStorage.getItem('antialias') || 'on') === 'on'
            );
        };
        // ç§»é™¤è®¾ç½®çª—å£AIæ•°é‡ç›¸å…³é€»è¾‘
        // æ¸¸æˆå¼€å§‹ç•Œé¢é€»è¾‘
        function showStartModal() {
            document.getElementById('start-modal').style.display = 'flex';
        }
        function hideStartModal() {
            document.getElementById('start-modal').style.display = 'none';
        }
        document.getElementById('start-btn').onclick = async function() {
            aiCount = Math.max(0, Math.min(3, parseInt(document.getElementById('start-ai-count').value)||0));
            hideStartModal();
            gameStarted = true;
            await createGame(
                (localStorage.getItem('antialias') || 'on') === 'off',
                (localStorage.getItem('antialias') || 'on') === 'on'
            );
        };
        // é‡æ–°å¼€å§‹æ—¶å›åˆ°å¼€å§‹ç•Œé¢
        window.showStartModal = showStartModal;
        // ä¿®æ”¹èƒœåˆ©å¼¹çª—æŒ‰é’®é€»è¾‘
        window.showWinnerModal = function(name) {
            if (document.getElementById('winner-modal')) return;
            const modal = document.createElement('div');
            modal.id = 'winner-modal';
            modal.style.position = 'fixed';
            modal.style.left = '0';
            modal.style.top = '0';
            modal.style.right = '0';
            modal.style.bottom = '0';
            modal.style.background = 'radial-gradient(ellipse at center, #181c2a 60%, #10121a 100%)';
            modal.style.zIndex = '10001';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.overflow = 'hidden';
            modal.innerHTML = `
                <div id="winner-panel" style="background:linear-gradient(135deg,#23243a 60%,#23243a 100%);border-radius:22px;box-shadow:0 8px 32px #111b,0 0 0 2px #3338;padding:48px 48px 32px 48px;min-width:360px;min-height:220px;display:flex;flex-direction:column;align-items:center;gap:18px;animation:popIn 0.7s cubic-bezier(.4,1.6,.6,1);border:1.5px solid #3af;box-shadow:0 0 40px #3af8,0 0 0 2px #3338;position:relative;">
                    <div class="start-title" style="font-size:32px;">èƒœåˆ©è€…</div>
                    <div class="winner-trophy" style="font-size:64px;color:gold;text-shadow:0 2px 12px #ff0a,0 0 8px #fff8;">ğŸ†</div>
                    <div class="winner-name" style="font-size:28px;font-weight:bold;color:#fff;margin-bottom:8px;text-shadow:0 2px 8px #222a;">${name}</div>
                    <button class="winner-btn" style="background:linear-gradient(90deg,#4a6cff 60%,#6cf 100%);color:#fff;border:none;border-radius:8px;font-size:18px;font-weight:bold;padding:10px 36px;cursor:pointer;box-shadow:0 2px 8px #2224;transition:background 0.2s;margin-top:12px;" onclick="document.getElementById('winner-modal').remove();showStartModal();">å†æ¥ä¸€å±€</button>
                </div>
            `;
            document.body.appendChild(modal);
        };
        // åˆå§‹æ˜¾ç¤ºå¼€å§‹ç•Œé¢
        showStartModal();
        // è¯»å–æŠ—é”¯é½¿è®¾ç½®
        let antialiasSetting = localStorage.getItem('antialias') || 'on';
        createGame(antialiasSetting === 'off', antialiasSetting === 'on');
    </script>
    <script>
    // ç¦ç”¨å³é”®èœå•ï¼Œé˜²æ­¢å³é”®å½±å“æ¸¸æˆä½“éªŒ
    window.addEventListener('contextmenu', function(e) { e.preventDefault(); });
    </script>
    <script>
    // çº¢æ™•é—ªçƒæ•ˆæœ
    let flashLayer = document.getElementById('red-flash-layer');
    if (!flashLayer) {
        flashLayer = document.createElement('div');
        flashLayer.id = 'red-flash-layer';
        flashLayer.style.position = 'fixed';
        flashLayer.style.left = '0';
        flashLayer.style.top = '0';
        flashLayer.style.width = '100vw';
        flashLayer.style.height = '100vh';
        flashLayer.style.pointerEvents = 'none';
        flashLayer.style.zIndex = '9999';
        flashLayer.style.transition = 'opacity 0.2s';
        document.body.appendChild(flashLayer);
    }
    if (Date.now() - redFlashTimer < 300) {
        flashLayer.style.opacity = '0.55';
        flashLayer.style.background = 'radial-gradient(ellipse at center, rgba(255,0,0,0.12) 40%, rgba(255,0,0,0.35) 100%)';
    } else {
        flashLayer.style.opacity = '0';
    }
    </script>
    <style>
    #winner-modal {
        position: fixed;
        left: 0; top: 0; right: 0; bottom: 0;
        background: rgba(30,30,40,0.55);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #winner-panel {
        background: linear-gradient(135deg, #23243a 60%, #3a3a5a 100%);
        border-radius: 22px;
        box-shadow: 0 8px 32px #111b, 0 0 0 2px #3338;
        padding: 48px 48px 32px 48px;
        min-width: 340px;
        min-height: 220px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 18px;
        animation: winner-pop 0.5s cubic-bezier(.4,1.6,.6,1);
    }
    @keyframes winner-pop {
        0% { transform: scale(0.7); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
    }
    .winner-trophy {
        font-size: 64px;
        margin-bottom: 8px;
        color: gold;
        text-shadow: 0 2px 12px #ff0a, 0 0 8px #fff8;
    }
    .winner-name {
        font-size: 28px;
        font-weight: bold;
        color: #fff;
        margin-bottom: 8px;
        text-shadow: 0 2px 8px #222a;
    }
    .winner-btn {
        background: linear-gradient(90deg, #4a6cff 60%, #6cf 100%);
        color: #fff;
        border: none;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        padding: 10px 36px;
        cursor: pointer;
        box-shadow: 0 2px 8px #2224;
        transition: background 0.2s;
        margin-top: 12px;
    }
    .winner-btn:hover {
        background: linear-gradient(90deg, #6cf 60%, #4a6cff 100%);
    }
    </style>
    <script>
    function showWinnerModal(name) {
        if (document.getElementById('winner-modal')) return;
        const modal = document.createElement('div');
        modal.id = 'winner-modal';
        modal.innerHTML = `
            <div id="winner-panel">
                <div class="winner-trophy">ğŸ†</div>
                <div class="winner-name">${name}</div>
                <button class="winner-btn" onclick="window.location.reload()">å†æ¥ä¸€å±€</button>
            </div>
        `;
        document.body.appendChild(modal);
    }
    function getAIWinnerName() {
        // åªè¿”å›ç¬¬ä¸€ä¸ªå­˜æ´»AIçš„åå­—
        for (let i = 0; i < aiTanks.length; i++) {
            if (aiAlive[i]) return `AI${i+1}`;
        }
        return 'AI';
    }
    </script>
    <script>
    // ESCè®¾ç½®æ—¶æš‚åœ/æ¢å¤
    let gamePaused = false;
    const oldOpenSettings3 = openSettings;
    openSettings = function() {
        gamePaused = true;
        oldOpenSettings3();
    };
    const oldCloseSettings = closeSettings;
    closeSettings = function() {
        gamePaused = false;
        oldCloseSettings();
        // å¦‚æœè¿˜åœ¨å¼€å§‹ç•Œé¢ï¼Œä»€ä¹ˆéƒ½ä¸åš
        if (document.getElementById('start-modal').style.display === 'flex') return;
    };

    // æ‰€æœ‰ç©å®¶å¤´é¡¶è¡€é‡æ¡
    let hpBarLayer = document.getElementById('tank-hp-bar-layer');
    if (!hpBarLayer) {
        hpBarLayer = document.createElement('div');
        hpBarLayer.id = 'tank-hp-bar-layer';
        hpBarLayer.style.position = 'fixed';
        hpBarLayer.style.left = '0';
        hpBarLayer.style.top = '0';
        hpBarLayer.style.width = '100vw';
        hpBarLayer.style.height = '100vh';
        hpBarLayer.style.pointerEvents = 'none';
        hpBarLayer.style.zIndex = '10000';
        document.body.appendChild(hpBarLayer);
    }
    function showTankHpBar(x, y, hit, maxHit, name, alive) {
        // å¦å…‹ä¸–ç•Œåæ ‡è½¬å±å¹•åæ ‡
        const canvas = game.canvas;
        const rect = canvas.getBoundingClientRect();
        const scale = scaleInfo.scale;
        const sx = rect.left + x * scale;
        const sy = rect.top + y * scale;
        let id = `tank-hp-bar-${name}`;
        let bar = document.getElementById(id);
        if (!bar) {
            bar = document.createElement('div');
            bar.id = id;
            bar.style.position = 'absolute';
            bar.style.width = '60px';
            bar.style.height = '10px';
            bar.style.background = '#2a2a2a';
            bar.style.borderRadius = '5px';
            bar.style.border = '1.5px solid #aa2222';
            bar.style.boxShadow = '0 0 4px #aa222288';
            bar.style.pointerEvents = 'none';
            bar.style.transition = 'opacity 0.2s';
            bar.innerHTML = `<div style="position:absolute;left:0;top:0;height:100%;background:linear-gradient(90deg,#22dd22 60%,#66ff66 100%);border-radius:5px;transition:width 0.3s;z-index:1;" id="${id}-fg"></div><div style="position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:bold;color:#fff;text-shadow:0 1px 2px #222,0 0 2px #fff8;z-index:2;">${name} ${Math.max(0,Math.round((1-hit/maxHit)*100))}/100</div>`;
            hpBarLayer.appendChild(bar);
        }
        bar.style.left = (sx - 30) + 'px';
        bar.style.top = (sy - 38) + 'px';
        bar.style.opacity = alive ? '1' : '0.2';
        let fg = document.getElementById(`${id}-fg`);
        if (fg) fg.style.width = `${Math.max(0, (1-hit/maxHit)*100)}%`;
        bar.children[1].textContent = `${name} ${Math.max(0,Math.round((1-hit/maxHit)*100))}/100`;
    }

    // ç©å®¶æ­»äº¡/AIæ­»äº¡çˆ†ç‚¸ç²’å­ç‰¹æ•ˆ
    function showDeathParticles(x, y) {
        const canvas = game.canvas;
        const rect = canvas.getBoundingClientRect();
        const scale = scaleInfo.scale;
        const sx = rect.left + x * scale;
        const sy = rect.top + y * scale;
        for (let i = 0; i < 18; i++) {
            let p = document.createElement('div');
            p.style.position = 'absolute';
            p.style.left = sx + 'px';
            p.style.top = sy + 'px';
            p.style.width = '8px';
            p.style.height = '8px';
            p.style.borderRadius = '50%';
            p.style.background = `hsl(${Math.random()*40+30},100%,60%)`;
            p.style.zIndex = '10001';
            p.style.pointerEvents = 'none';
            let angle = Math.random() * Math.PI * 2;
            let dist = Math.random() * 60 + 30;
            let dx = Math.cos(angle) * dist;
            let dy = Math.sin(angle) * dist;
            p.style.transition = 'all 0.7s cubic-bezier(.4,1.6,.6,1)';
            document.body.appendChild(p);
            setTimeout(() => {
                p.style.left = (sx + dx) + 'px';
                p.style.top = (sy + dy) + 'px';
                p.style.opacity = '0';
            }, 10);
            setTimeout(() => p.remove(), 800);
        }
    }
    </script>
    <script>
    window.addEventListener('resize', safeUpdateMapWrapperCenter);
    setInterval(safeUpdateMapWrapperCenter, 200); // åŠ¨æ€ç›‘å¬é¢æ¿å®½åº¦å˜åŒ–
    setTimeout(safeUpdateMapWrapperCenter, 500);
    </script>
    <script>
    // å¼€å§‹ç•Œé¢åŠ¨ç”»èƒŒæ™¯
    function startBgTankAnim() {
        const canvas = document.getElementById('start-bg-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        let t = 0;
        function drawTank(x, y, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            // æœºèº«
            ctx.fillStyle = color;
            ctx.shadowColor = '#3af';
            ctx.shadowBlur = 16;
            ctx.fillRect(-18, -18, 36, 36);
            ctx.shadowBlur = 0;
            // ç‚®ç®¡
            ctx.fillStyle = '#fff';
            ctx.fillRect(-4, -36, 8, 28);
            ctx.restore();
        }
        function drawEnemy(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = '#444';
            ctx.fillRect(-16, -16, 32, 32);
            ctx.fillStyle = '#aaf';
            ctx.fillRect(-3, -28, 6, 20);
            ctx.restore();
        }
        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // æ˜Ÿæ˜Ÿ
            for (let i = 0; i < 80; i++) {
                let sx = (i * 97 + t * 0.2 * (i%3+1)) % canvas.width;
                let sy = (i * 53 + t * 0.13 * (i%5+1)) % canvas.height;
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 0.2 + 0.8 * ((i%7)/7);
                ctx.beginPath(); ctx.arc(sx, sy, 1.2 + (i%3), 0, Math.PI*2); ctx.fill();
            }
            ctx.globalAlpha = 1;
            // å¦å…‹ä¸»è§’
            let tx = canvas.width/2 + Math.sin(t/80)*180;
            let ty = canvas.height/2 + Math.cos(t/120)*120;
            let tankAngle = Math.sin(t/100)*0.5;
            drawTank(tx, ty, tankAngle, '#3af');
            // æ•Œæ–¹å¦å…‹
            for (let i = 0; i < 3; i++) {
                let ex = canvas.width/2 + Math.sin(t/60+i*2)*320;
                let ey = canvas.height/2 + Math.cos(t/80+i*2)*200;
                let eAngle = Math.atan2(ty-ey, tx-ex);
                drawEnemy(ex, ey, eAngle);
                // å­å¼¹
                ctx.save();
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(ex + Math.cos(eAngle)*20, ey + Math.sin(eAngle)*20);
                ctx.lineTo(ex + Math.cos(eAngle)*60, ey + Math.sin(eAngle)*60);
                ctx.stroke();
                ctx.restore();
            }
            // ä¸»è§’å­å¼¹
            ctx.save();
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(tx, ty-36);
            ctx.lineTo(tx, ty-120);
            ctx.stroke();
            ctx.restore();
            t++;
            requestAnimationFrame(loop);
        }
        loop();
    }
    startBgTankAnim();
    // å¼€å§‹ç•Œé¢æŒ‰é’®é€»è¾‘
    document.getElementById('start-settings-btn').onclick = function() {
        openSettings();
    };
    document.getElementById('start-maker-btn').onclick = function() {
        document.getElementById('maker-modal').style.display = 'flex';
    };
    </script>
    <script>
    // æ¸¸æˆä¸»ç•Œé¢ç‚¹å‡»èƒŒæ™¯è§¦å‘å°çƒç‚¸å¼€ç‰¹æ•ˆ
    document.querySelector('.map-wrapper').addEventListener('click', function(e) {
        // åªåœ¨æ¸¸æˆå·²å¼€å§‹æ—¶ç”Ÿæ•ˆ
        if (!gameStarted) return;
        const rect = this.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        for (let i = 0; i < 18; i++) {
            let p = document.createElement('div');
            p.style.position = 'absolute';
            p.style.left = (rect.left + x) + 'px';
            p.style.top = (rect.top + y) + 'px';
            p.style.width = '10px';
            p.style.height = '10px';
            p.style.borderRadius = '50%';
            p.style.background = `hsl(${Math.random()*360},100%,60%)`;
            p.style.zIndex = '10009';
            p.style.pointerEvents = 'none';
            let angle = Math.random() * Math.PI * 2;
            let dist = Math.random() * 60 + 30;
            let dx = Math.cos(angle) * dist;
            let dy = Math.sin(angle) * dist;
            p.style.transition = 'all 0.7s cubic-bezier(.4,1.6,.6,1)';
            document.body.appendChild(p);
            setTimeout(() => {
                p.style.left = (rect.left + x + dx) + 'px';
                p.style.top = (rect.top + y + dy) + 'px';
                p.style.opacity = '0';
            }, 10);
            setTimeout(() => p.remove(), 800);
        }
    });
    // è‡ªå®šä¹‰é¼ æ ‡æ ·å¼è·Ÿéš
    const cursor = document.getElementById('custom-cursor');
    document.addEventListener('mousemove', function(e) {
        cursor.style.left = (e.clientX - 16) + 'px';
        cursor.style.top = (e.clientY - 16) + 'px';
    });
    </script>
    <script>
    // è®¾ç½®ç•Œé¢å¢åŠ å›åˆ°æ¸¸æˆUIç•Œé¢æŒ‰é’®ï¼Œç§»é™¤AIæ•°é‡è®¾ç½®é¡¹ï¼Œè®¾ç½®è‡ªåŠ¨ä¿å­˜
    // è‡ªåŠ¨ä¿å­˜è®¾ç½®
    function saveUserSettings() {
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('tankColor', tankColor);
        localStorage.setItem('bulletColor', BULLET_COLOR);
        localStorage.setItem('glowColor', glowColor);
    }
    function loadUserSettings() {
        if (localStorage.getItem('playerName')) playerName = localStorage.getItem('playerName');
        if (localStorage.getItem('tankColor')) tankColor = parseInt(localStorage.getItem('tankColor'));
        if (localStorage.getItem('bulletColor')) BULLET_COLOR = parseInt(localStorage.getItem('bulletColor'));
        if (localStorage.getItem('glowColor')) glowColor = parseInt(localStorage.getItem('glowColor'));
    }
    loadUserSettings();
    // è®¾ç½®ç•Œé¢å›åˆ°æ¸¸æˆUIæŒ‰é’®
    let settingsPanel = document.getElementById('settings-panel');
    if (settingsPanel && !document.getElementById('back-to-start-btn')) {
        let backBtn = document.createElement('button');
        backBtn.id = 'back-to-start-btn';
        backBtn.textContent = 'å›åˆ°æ¸¸æˆUIç•Œé¢';
        backBtn.style.marginTop = '12px';
        backBtn.style.background = 'linear-gradient(90deg, #4a6cff 60%, #6cf 100%)';
        backBtn.style.color = '#fff';
        backBtn.style.border = 'none';
        backBtn.style.borderRadius = '8px';
        backBtn.style.fontSize = '16px';
        backBtn.style.fontWeight = 'bold';
        backBtn.style.padding = '8px 28px';
        backBtn.style.cursor = 'pointer';
        backBtn.style.boxShadow = '0 2px 8px #2224';
        backBtn.onclick = function() {
            closeSettings();
            showStartModal();
        };
        settingsPanel.appendChild(backBtn);
    }
    // è®¾ç½®é¡¹å˜æ›´æ—¶è‡ªåŠ¨ä¿å­˜
    document.getElementById('name-input').oninput = function() { playerName = this.value; saveUserSettings(); };
    document.getElementById('tank-color-input').oninput = function() { tankColor = hexToPhaserColor(this.value); if (tank && tank.list && tank.list[0]) tank.list[0].fillColor = tankColor; saveUserSettings(); };
    document.getElementById('bullet-color-input').oninput = function() { BULLET_COLOR = hexToPhaserColor(this.value); saveUserSettings(); };
    document.getElementById('glow-color-input').oninput = function() { glowColor = hexToPhaserColor(this.value); if (tank && tank.list && tank.list[0]) tank.list[0].setStrokeStyle(6, glowColor, 0.7); if (tank && tank.list && tank.list[1]) tank.list[1].setStrokeStyle(4, glowColor, 0.6); saveUserSettings(); };
    </script>
</body>
</html> 